import numpy as np

def labelToMat(labelIn):
    """
    Change the label to matrix as the following:
        [0,1,2,1,1] =>  [1,0,0]
                        [0,1,0]
                        [0,0,1]
                        [0,1,0]
                        [0,1,0]
    Parameters:
        labelIn: List, the list of the labels
    """
    labelSet = set(labelIn)
    arrLength = len(labelSet)
    baseArr = [0] * arrLength
    labelArrDict = {}
    arrLabelDict = {}
    for i, label in enumerate(np.sort(list(labelSet))):
        tmpArr = baseArr.copy()
        tmpArr[i] += 1
        labelArrDict[label] = tmpArr
        arrLabelDict[tuple(tmpArr)] = label
    labelOut = []
    for label in labelIn:
        labelOut.append(labelArrDict[label])
    return np.array(labelOut),labelArrDict,arrLabelDict

def adjchu(test,input_dim1, useBool = False):
    A = np.zeros((len(test), input_dim1, input_dim1)) + np.eye(input_dim1)
    DList = []
    for j in range(len(test)):
        for i in range(len(test[j])-1):
            pos0 = test[j][i]
            pos1 = test[j][i+1]
            A[j][pos0][pos1] += 1
        if useBool:
            D = A[j].astype(bool).sum(axis=1) * np.eye(input_dim1)
            D = np.power(D, -1)
            D[~ np.isfinite(D)] = 0
        else:
            D = A[j].sum(axis=1) * np.eye(input_dim1)
            D = np.power(D, -1)
            D[~ np.isfinite(D)] = 0
        DList.append(D)
    if useBool:
        return A.astype(bool).astype(int), np.array(DList)
    return A, np.array(DList)  #返回邻接矩阵+单位矩阵 ， 出度 度矩阵

def adjru(test,input_dim1, useBool = False):
    A = np.zeros((len(test), input_dim1, input_dim1)) + np.eye(input_dim1)
    DList = []
    for j in range(len(test)):
        for i in range(len(test[j])-1):
            pos0 = test[j][i]
            pos1 = test[j][i+1]
            A[j][pos0][pos1] += 1
        if useBool:
            D = A[j].astype(bool).sum(axis=0) * np.eye(input_dim1)
            D = np.power(D, -1)
            D[~ np.isfinite(D)] = 0
        else:
            D = A[j].sum(axis=0) * np.eye(input_dim1)
            D = np.power(D, -1)
            D[~ np.isfinite(D)] = 0
        DList.append(D)
    if useBool:
        return A.astype(bool).astype(int), np.array(DList)
    return A, np.array(DList)  #返回邻接矩阵+单位矩阵 ， 入度 度矩阵

def to_one_hot(X, input_dim_1):
    tmpX = np.array(X)
    outArr = np.zeros([tmpX.shape[0], input_dim_1, tmpX.shape[1]])
    for i in range(tmpX.shape[0]):
        for j in range(tmpX.shape[1]):
            outArr[i, int(tmpX[i, j]), j] = 1
    return outArr

def Multiply(M1,M2,M3):
    tmp = np.einsum("ijk,ikn->ijn", M1, M2)
    outmat = np.einsum("ijk,ikn->ijn", tmp, M3)
    return outmat

lengths = []
dataList = []
yList = []
with open('Sample_data.csv') as FID:
    lineCount = 0
    for line in FID:
        lineCount += 1
        if lineCount == 1:
            continue
        eles = line.strip().strip(',').split(',')
        tmpdata = np.array(eles[1:-1],dtype=int)
        lengths.append(len(tmpdata))
        dataList.append(tmpdata)
        yList.append(int(eles[-1]))

A,Dc = adjchu(dataList,295,useBool=True)
A,Dr = adjru(dataList,295,useBool=True)
At = A.transpose(0,2,1) #邻接矩阵转置
X = to_one_hot(dataList,295)
ADcX = Multiply(A,Dc,X)  #邻接矩阵出度图编码结果
AtDrX = Multiply(At,Dr,X) #邻接矩阵入度图编码结果

np.savez('tmpADcX',ADcX)
np.savez('tmpAtDrX',AtDrX)